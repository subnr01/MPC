{\rtf1\ansi\ansicpg1252\cocoartf1348\cocoasubrtf170
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red100\green56\blue32;\red196\green26\blue22;\red170\green13\blue145;
\red92\green38\blue153;\red28\green0\blue207;\red0\green116\blue0;\red63\green110\blue116;\red38\green71\blue75;
\red46\green13\blue110;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural

\f0\fs22 \cf0 \CocoaLigature0 for file in *.png; \
do convert $file -resize 180x144 $file; \
done\
\
\
\
for file in *.png; \
do convert $file -crop 140x91+15+10 $file;\
done\
\
\
===============================\
\pard\tx529\pardeftab529\pardirnatural
\cf2 #include \cf3 <iostream>\cf2 \
#include \cf3 <sys/types.h>\cf2 \
#include \cf3 <sys/socket.h>\cf2 \
#include \cf3 <netinet/in.h>\cf2 \
#include \cf3 <arpa/inet.h>\cf2 \
#include \cf3 <unistd.h>\cf2 \
\cf0 \
\cf2 #include \cf3 "util.h"\cf2 \
#include \cf3 "IntImage.h"\cf2 \
#include \cf3 <opencv2/opencv.hpp>\cf2 \
#include \cf3 <opencv2/highgui/highgui.hpp>\cf2 \
#include \cf3 <pthread.h>\cf2 \
#include \cf3 <fstream>\cf2 \
\cf0 \
\cf4 using\cf0  \cf4 namespace\cf0  \cf5 std\cf0 ;\
\cf4 using\cf0  \cf4 namespace\cf0  \cf5 cv\cf0 ;\
\
\
\cf2 #define DEBUG \cf6 1\cf2 \
#define TCP \cf6 0\cf2 \
#define UDP \cf6 1\cf2 \
\cf0 \
\
\
\cf4 void\cf0  *receiveData(\cf4 void\cf0  *);\
\
\cf4 struct\cf0  \cf5 sockaddr_in\cf0  addr;\
\
\cf7 // Draw rectangle function\cf0 \
\
\cf4 void\cf0  drawRect(\cf8 IntImage\cf0 * dest, \cf4 int\cf0  cx, \cf4 int\cf0  cy, \cf4 int\cf0  w, \cf4 int\cf0  h, \cf4 int\cf0  r, \cf4 int\cf0  g, \cf4 int\cf0  b)\
\{\
    \cf4 int\cf0 * rc = dest->\cf9 getChannel\cf0 (\cf6 0\cf0 );\
    \cf4 int\cf0 * gc = dest->\cf9 getChannel\cf0 (\cf6 1\cf0 );\
    \cf4 int\cf0 * bc = dest->\cf9 getChannel\cf0 (\cf6 2\cf0 );\
    \cf4 int\cf0  iw = dest->\cf9 width\cf0 ();\
    \cf4 int\cf0  ih = dest->\cf9 height\cf0 ();\
    \
    \cf7 // left edge\cf0 \
    \cf4 for\cf0 (\cf4 int\cf0  y = cy; y < \cf5 std\cf0 ::\cf10 min\cf0 (ih, cy + h); ++y)\
    \{\
        rc[(y * iw) + cx] = r;\
        gc[(y * iw) + cx] = g;\
        bc[(y * iw) + cx] = b;\
    \}\
    \
    \cf7 // right edge\cf0 \
    \cf4 if\cf0 (cx + w < iw)\
    \{\
        \cf4 for\cf0 (\cf4 int\cf0  y = cy; y < \cf5 std\cf0 ::\cf10 min\cf0 (ih, cy + h); ++y)\
        \{\
            rc[(y * iw) + cx + w] = r;\
            gc[(y * iw) + cx + w] = g;\
            bc[(y * iw) + cx + w] = b;\
        \}\
    \}\
    \
    \cf7 // top edge\cf0 \
    \cf4 for\cf0 (\cf4 int\cf0  x = cx; x < \cf5 std\cf0 ::\cf10 min\cf0 (iw, cx + w); ++x)\
    \{\
        rc[(cy * iw) + x] = r;\
        gc[(cy * iw) + x] = g;\
        bc[(cy * iw) + x] = b;\
    \}\
    \
    \cf7 // bottom edge\cf0 \
    \cf4 if\cf0 (cy + h < ih)\
    \{\
        \cf4 for\cf0 (\cf4 int\cf0  x = cx; x < \cf5 std\cf0 ::\cf10 min\cf0 (iw, cx + w); ++x)\
        \{\
            rc[((cy + h) * iw) + x] = r;\
            gc[((cy + h) * iw) + x] = g;\
            bc[((cy + h) * iw) + x] = b;\
        \}\
    \}\
\}\
\
\
\cf4 int\cf0  main()\
\{\
    \cf4 int\cf0  sockfd;\
    \cf4 int\cf0  send_len;\
    \
    \cf4 int\cf0  frame_count=\cf6 0\cf0 ;\
    \
  \cf7 //  char *serverip = "127.0.0.1";\cf0 \
    \cf4 char\cf0  *serverip = \cf3 "128.2.213.227"\cf0 ;\
    \
    \cf7 //char *server_ip = "128.2.213.222";\cf0 \
    \cf5 pthread_t\cf0  receive_thread;\
    \cf4 double\cf0  width = \cf6 640\cf0 ;\
    \cf4 double\cf0  height = \cf6 480\cf0 ;\
    \cf5 IplImage\cf0  *frame = \cf6 0\cf0 ;\
    \cf5 cv\cf0 ::\cf5 Mat\cf0  Mimg;\
    \cf5 vector\cf0 <\cf5 uchar\cf0 > ibuff;\
    \cf5 vector\cf0 <\cf4 int\cf0 > param = \cf5 vector\cf0 <\cf4 int\cf0 >(\cf6 2\cf0 );\
    \cf4 char\cf0  windowName[] = \cf3 "Client Camera"\cf0 ;\
    \cf4 int\cf0  sendSize = \cf6 65535\cf0 ;\
    \cf4 char\cf0  buff[sendSize];\
    \
    \cf4 char\cf0  buff1[\cf6 1024\cf0 ];\
\
    \
    \cf7 //sockfd = establishUDP(server_ip);\cf0 \
    \
    \cf4 if\cf0  (\cf2 UDP\cf0 ) \{\
        \cf4 if\cf0  (\cf2 DEBUG\cf0 ) \{\
            \cf5 cout\cf0 <<\cf3 "\\n Establishing UDP connection \\n"\cf0 ;\
        \}\
        sockfd = \cf9 establishUDP\cf0 (serverip);\
    \}\
    \cf4 else\cf0  \cf4 if\cf0  (\cf2 TCP\cf0 ) \{\
        \cf4 if\cf0  (\cf2 DEBUG\cf0 ) \{\
            \cf5 cout\cf0 <<\cf3 "\\n Establishing TCP connection \\n"\cf0 ;\
        \}\
        sockfd = \cf9 establishTCPConnection\cf0 (serverip);\
    \}\
    \
    \cf7 /*\
     * run the receiving thread\
     */\cf0 \
\cf7 /*    if (pthread_create(&receive_thread, NULL, receiveData, &sockfd)) \{\
        printf("\\n--> pthread_create failed.");\
    \}\
*/\cf0 \
    \
    \cf5 CvCapture\cf0  *capture = \cf10 cvCreateCameraCapture\cf0 (\cf6 0\cf0 );\
    \cf10 cvSetCaptureProperty\cf0  (capture, \cf10 CV_CAP_PROP_FRAME_WIDTH\cf0 , width);\
    \cf10 cvSetCaptureProperty\cf0  (capture, \cf10 CV_CAP_PROP_FRAME_HEIGHT\cf0 , height);\
    \
    \cf10 cvSetCaptureProperty\cf0 (capture, \cf10 CV_CAP_PROP_FPS\cf0 , \cf6 3.0\cf0 );\
    \
    \cf10 cvNamedWindow\cf0  (windowName, \cf10 CV_WINDOW_AUTOSIZE\cf0 );\
    \
    \
    \cf7 /*\
     * Perform jpeg compression\
     */\cf0 \
    frame = \cf10 cvQueryFrame\cf0  (capture);\
    Mimg = \cf10 cvarrToMat\cf0 (frame);\
    param[\cf6 0\cf0 ] = \cf10 CV_IMWRITE_JPEG_QUALITY\cf0 ;\
    param[\cf6 1\cf0 ] = \cf6 50\cf0 ;\
    \
    \
    \cf10 imencode\cf0 (\cf3 ".jpg"\cf0 , Mimg, ibuff, param);\
    \cf4 if\cf0  (\cf2 DEBUG\cf0 ) \{\
        \cf5 cout\cf0 <<\cf3 "coded file size(jpg)"\cf0 <<ibuff.\cf10 size\cf0 ()<<\cf10 endl\cf0 ;\
    \}\
    \
    \cf4 while\cf0  (\cf6 1\cf0 ) \{\
        \
        frame_count++;\
        frame = \cf10 cvQueryFrame\cf0  (capture);\
        Mimg = \cf10 cvarrToMat\cf0 (frame);\
        \
        \cf4 if\cf0 (capture)\
             \cf5 cout\cf0 <<\cf3 "uh oh :"\cf0 <<\cf10 endl\cf0 ;\
        \
    \
        \cf10 imencode\cf0 (\cf3 ".jpg"\cf0 , Mimg, ibuff, param);\
        \cf4 for\cf0  (\cf4 int\cf0  i = \cf6 0\cf0 ; i < ibuff.\cf10 size\cf0 (); i++)\
        \{\
            buff[i]=ibuff[\cf10 i\cf0 ];\
        \}\
        \cf4 if\cf0  (\cf2 UDP\cf0 ) \{\
            \cf4 if\cf0  (\cf2 DEBUG\cf0 ) \{\
                \cf5 cout\cf0 <<\cf3 "\\n Sending Image \\n"\cf0 ;\
            \}\
            send_len = \cf10 sendto\cf0 (sockfd, buff, ibuff.\cf10 size\cf0 (), \cf6 0\cf0 , (\cf4 struct\cf0  \cf5 sockaddr\cf0  *)&\cf8 addr\cf0 , \cf4 sizeof\cf0 (\cf8 addr\cf0 ));\
        \}\
        \cf4 if\cf0  (send_len == -\cf6 1\cf0 )\
        \{\
            \cf10 perror\cf0 (\cf3 "socket"\cf0 );\
            \cf10 exit\cf0 (\cf6 1\cf0 );\
        \} \cf4 else\cf0 \
        \{\
            \cf10 printf\cf0 (\cf3 "buffer size %lu \\n"\cf0 , ibuff.\cf10 size\cf0 ());\
        \}\
        \
        \cf7 //rectangle(Mimg,Point(20,0),Point(170,65),Scalar(255,255,0),1,8,0);\cf0 \
        \cf10 imshow\cf0 (windowName, Mimg);\
        \
        \cf4 if\cf0  (\cf2 DEBUG\cf0 ) \{\
            \cf5 cout\cf0 <<\cf3 "\\n Receive thread starts"\cf0 <<\cf10 endl\cf0 ;\
        \}\
        \
             \cf7 //  int *sockfd = (int*)arg;\cf0 \
  \cf7 //      pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);\cf0 \
    \cf7 //    pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);\cf0 \
      \cf7 //  usleep(10000);\cf0 \
        \cf4 int\cf0  i = \cf6 0\cf0 ;\
        \cf4 int\cf0  j = \cf6 0\cf0 ;\
        \
        \cf7 //while(i < 65,500)\cf0 \
  \cf7 //      while (1)\cf0 \
    \cf7 //    \{\cf0 \
        \cf4 if\cf0 (frame_count>\cf6 10\cf0 )\
        \{\
            \
            \cf5 cout\cf0 <<\cf3 "Frame count:"\cf0 <<frame_count<<\cf10 endl\cf0 ;\
\
            \cf10 memset\cf0 (buff1, \cf6 0\cf0 , \cf6 1024\cf0 );\
            \cf4 int\cf0  received = \cf10 recvfrom\cf0 (sockfd, buff1, \cf6 1024\cf0 , \cf6 0\cf0 , \cf4 NULL\cf0 ,\cf4 NULL\cf0 );\
            \
            \cf5 cout\cf0 <<\cf10 endl\cf0 <<\cf3 "Received data"\cf0 <<\cf10 endl\cf0 ;\
            \
            \cf4 if\cf0  ( received != -\cf6 1\cf0 )\
            \{\
                buff1[received] = \cf6 '\\0'\cf0 ;\
            \}\
            \
            \cf5 cout\cf0 <<\cf3 "\\n Received buffer data "\cf0 <<buff1<<\cf10 endl\cf0 ;\
            \
            \
            \cf4 if\cf0  ( !\cf10 strcmp\cf0 (buff1, \cf3 "left"\cf0 )) \{\
                \cf10 system\cf0 (\cf3 "/Users/priyankakulkarni/Documents/Project/MPC/keyboard/simulate_keypress_right_print"\cf0 ); \cf7 //print opposite due to mirror image\cf0 \
                \
            \}\
            \cf4 else\cf0  \cf4 if\cf0  ( !\cf10 strcmp\cf0 (buff1, \cf3 "right"\cf0 )) \{\
                \cf10 system\cf0 (\cf3 "/Users/priyankakulkarni/Documents/Project/MPC/keyboard/simulate_keypress_left_print"\cf0 ); \cf7 //print opposite due to mirror image\cf0 \
                \
            \}\
            \cf4 else\cf0  \cf4 if\cf0  ( !\cf10 strcmp\cf0 (buff1, \cf3 "idle"\cf0 )) \{\
                \cf10 system\cf0 (\cf3 "/Users/priyankakulkarni/Documents/Project/MPC/keyboard/simulate_keypress_idle_print"\cf0 ); \cf7 //print opposite due to mirror image\cf0 \
                \
            \}\
            \cf4 else\cf0  \cf4 if\cf0  ( !\cf10 strcmp\cf0 (buff1, \cf3 "up"\cf0 )) \{\
                \cf10 system\cf0 (\cf3 "/Users/priyankakulkarni/Documents/Project/MPC/keyboard/simulate_keypress_down_print"\cf0 ); \cf7 //print opposite due tdo mirror image\cf0 \
                \
            \}\
            \cf4 else\cf0  \cf4 if\cf0  ( !\cf10 strcmp\cf0 (buff1, \cf3 "down"\cf0 )) \{\
                \cf10 system\cf0 (\cf3 "/Users/priyankakulkarni/Documents/Project/MPC/keyboard/simulate_keypress_up_print"\cf0 ); \cf7 //print opposite due to mirror image\cf0 \
                \
            \}\
            \
        \}\
            \cf7 /*\
             if ( i > 65,490 && j < 3 ) \{\
             i = 0;\
             j++;\
             \}*/\cf0 \
            \
            \
 \cf7 //           i++;\cf0 \
            \
        \cf7 //    pthread_testcancel();\cf0 \
            \
 \cf7 //       \}\cf0 \
        \
        \
        \cf4 int\cf0  process_width = \cf6 180\cf0 ;\
        \cf4 int\cf0  process_height = \cf6 144\cf0 ;\
        \cf4 int\cf0  display_width = \cf6 320\cf0 ;\
        \cf4 int\cf0  display_height = \cf6 240\cf0 ;\
        \
        \cf4 int\cf0  searchX = \cf6 20\cf0 ;\
        \cf4 int\cf0  searchY = \cf6 0\cf0 ;\
        \cf4 int\cf0  searchW = \cf6 140\cf0 ;\
        \cf4 int\cf0  searchH = \cf6 91\cf0 ;\
        \
        \cf5 IplImage\cf0 * ipl_Mimg_pointer;\
        \cf8 IntImage\cf0 * src_Mimg = \cf4 new\cf0  \cf8 IntImage\cf0 (process_width, process_height, \cf6 3\cf0 );\
        \cf8 IntImage\cf0 * dest_Mimg = \cf4 new\cf0  \cf8 IntImage\cf0 (process_width, process_height, \cf6 3\cf0 );\
        \cf5 IplImage\cf0 * display_temp = \cf10 cvCreateImage\cf0 (\cf10 cvSize\cf0 (process_width, process_height), \cf2 IPL_DEPTH_8U\cf0 , \cf6 3\cf0 );\
        \cf5 IplImage\cf0 * resizedSrcFrame = \cf10 cvCreateImage\cf0 (\cf10 cvSize\cf0 (display_width, display_height), \cf2 IPL_DEPTH_8U\cf0 , \cf6 3\cf0 );\
        \cf5 IplImage\cf0 * resizedPFrame = \cf10 cvCreateImage\cf0 (\cf10 cvSize\cf0 (process_width, process_height), \cf2 IPL_DEPTH_8U\cf0 , \cf6 3\cf0 );\
        \
        \cf5 IplImage\cf0  ipl_Mimg = Mimg;\
        \
        ipl_Mimg_pointer = &ipl_Mimg;\
        \
        \cf10 cvResize\cf0 (ipl_Mimg_pointer, resizedSrcFrame);\
        \cf10 cvResize\cf0 (ipl_Mimg_pointer, resizedPFrame);\
        \
        \
        src_Mimg->\cf9 copy\cf0 (resizedSrcFrame, \cf4 true\cf0 );\
        dest_Mimg->\cf9 copy\cf0 (resizedPFrame, \cf4 true\cf0 );\
        \
        \cf9 drawRect\cf0 (dest_Mimg, searchX, searchY, searchW, searchH, \cf6 255\cf0 , \cf6 255\cf0 , \cf6 255\cf0 );\
        \
        \cf9 drawRect\cf0 (dest_Mimg, \cf6 70\cf0 , searchY, \cf6 50\cf0 , searchH, \cf6 255\cf0 , \cf6 255\cf0 , \cf6 255\cf0 );\
        \
        dest_Mimg->\cf9 getIplImage\cf0 (display_temp);\
        \
        \cf10 cvShowImage\cf0 (\cf3 "Template Locations"\cf0 , display_temp);\
        \
        \cf4 int\cf0  c = \cf10 cvWaitKey\cf0  (\cf6 1\cf0 );\
        \cf4 if\cf0  (c == \cf6 'q'\cf0 )\
        \{\
            \cf4 break\cf0 ;\
        \}\
    \}\
    \
    \cf7 /* terminate the receiving thread */\cf0 \
    \cf4 if\cf0  (\cf10 pthread_cancel\cf0 (receive_thread) ) \{\
        \cf10 printf\cf0 (\cf3 "pthread_cancel failed."\cf0 );\
    \}\
    \
    \cf10 cvDestroyWindow\cf0 (windowName);\
    \cf10 close\cf0 (sockfd);\
    \cf4 return\cf0  \cf6 0\cf0 ;\
\}\
\
\
\
\cf7 /*\
 * thread to receive data\
 * continuously\
 */\cf0 \
\
\cf4 void\cf0  *receiveData(\cf4 void\cf0  *arg)\
\{\
    \cf4 if\cf0  (\cf2 DEBUG\cf0 ) \{\
        \cf5 cout\cf0 <<\cf3 "\\n Receive thread starts"\cf0 <<\cf10 endl\cf0 ;\
    \}\
    \
    \cf4 char\cf0  buff[\cf6 1024\cf0 ];\
    \cf4 int\cf0  *sockfd = (\cf4 int\cf0 *)arg;\
    \cf10 pthread_setcancelstate\cf0 (\cf2 PTHREAD_CANCEL_ENABLE\cf0 , \cf4 NULL\cf0 );\
    \cf10 pthread_setcanceltype\cf0 (\cf2 PTHREAD_CANCEL_ASYNCHRONOUS\cf0 , \cf4 NULL\cf0 );\
    \cf10 usleep\cf0 (\cf6 10000\cf0 );\
    \cf4 int\cf0  i = \cf6 0\cf0 ;\
    \cf4 int\cf0  j = \cf6 0\cf0 ;\
    \
    \cf7 //while(i < 65,500)\cf0 \
    \cf4 while\cf0  (\cf6 1\cf0 )\
    \{\
        \cf10 memset\cf0 (buff, \cf6 0\cf0 , \cf6 1024\cf0 );\
        \cf4 int\cf0  received = \cf10 recvfrom\cf0 (*sockfd, buff, \cf6 1024\cf0 , \cf6 0\cf0 , \cf4 NULL\cf0 ,\cf4 NULL\cf0 );\
        \
        \cf5 cout\cf0 <<\cf10 endl\cf0 <<\cf3 "Received data"\cf0 <<\cf10 endl\cf0 ;\
\
        \cf4 if\cf0  ( received != -\cf6 1\cf0 )\
        \{\
            buff[received] = \cf6 '\\0'\cf0 ;\
        \}\
\
        \cf5 cout\cf0 <<\cf3 "\\n Received buffer data "\cf0 <<buff<<\cf10 endl\cf0 ;\
\
        \
        \cf4 if\cf0  ( !\cf10 strcmp\cf0 (buff, \cf3 "left"\cf0 )) \{\
            \cf10 system\cf0 (\cf3 "/Users/priyankakulkarni/Documents/Project/MPC/keyboard/simulate_keypress_right_print"\cf0 ); \cf7 //print opposite due to mirror image\cf0 \
            \
        \}\
        \cf4 else\cf0  \cf4 if\cf0  ( !\cf10 strcmp\cf0 (buff, \cf3 "right"\cf0 )) \{\
            \cf10 system\cf0 (\cf3 "/Users/priyankakulkarni/Documents/Project/MPC/keyboard/simulate_keypress_left_print"\cf0 ); \cf7 //print opposite due to mirror image\cf0 \
            \
        \}\
              \cf4 else\cf0  \cf4 if\cf0  ( !\cf10 strcmp\cf0 (buff, \cf3 "idle"\cf0 )) \{\
            \cf10 system\cf0 (\cf3 "/Users/priyankakulkarni/Documents/Project/MPC/keyboard/simulate_keypress_idle_print"\cf0 ); \cf7 //print opposite due to mirror image\cf0 \
          \
        \}\
        \
        \cf7 /*\
        if ( i > 65,490 && j < 3 ) \{\
            i = 0;\
            j++;\
        \}*/\cf0 \
        \
        \
        i++;\
  \
        \cf10 pthread_testcancel\cf0 ();\
        \
    \}\
    \
    \cf5 cout\cf0 <<\cf3 "\\n THREAD EXITING \\n"\cf0 ;\
    \
    \
\}\
\
\
\cf7 /*\
 * Establish socket connection with\
 * the server\
 */\cf0 \
\
\cf7 //int establishUDP(const char *serverip) \{\cf0 \
\cf4 int\cf0  establishUDP(\cf4 char\cf0  *serverip) \{\
    \
    \cf4 int\cf0  sockfd = \cf10 socket\cf0 (\cf2 AF_INET\cf0 , \cf2 SOCK_DGRAM\cf0 , \cf6 0\cf0 );\
    \cf8 addr\cf0 .\cf5 sin_family\cf0  = \cf2 AF_INET\cf0 ;\
    \cf8 addr\cf0 .\cf5 sin_port\cf0  = \cf2 htons\cf0 (\cf2 PORT\cf0 );\
    \cf8 addr\cf0 .\cf5 sin_addr\cf0 .\cf5 s_addr\cf0  = \cf10 inet_addr\cf0 (serverip);\
    \
    \
    \cf4 int\cf0  n = \cf6 1024\cf0  * \cf6 1024\cf0 ;\
    \
    \cf4 if\cf0  (\cf10 setsockopt\cf0 (sockfd, \cf2 SOL_SOCKET\cf0 , \cf2 SO_RCVBUF\cf0 , &n, \cf4 sizeof\cf0 (n)) == -\cf6 1\cf0 ) \{\
        \cf10 printf\cf0 (\cf3 "\\n Error in setting socket options for rcvbuff"\cf0 );\
        \
    \}\
    \
    \cf4 if\cf0  (\cf10 setsockopt\cf0 (sockfd, \cf2 SOL_SOCKET\cf0 , \cf2 SO_SNDBUF\cf0 , &n, \cf4 sizeof\cf0 (n)) == -\cf6 1\cf0 ) \{\
        \cf10 printf\cf0 (\cf3 "\\n Error in setting socket options for rcvbuff"\cf0 );\
    \}\
    \
    \cf4 return\cf0  sockfd;\
    \
\}\
\
\
\cf4 int\cf0  establishTCPConnection(\cf4 char\cf0  *server_ip)\
\{\
    \
    \cf4 int\cf0  clientSock;\
    \cf4 struct\cf0   \cf5 sockaddr_in\cf0  serverAddr;\
    \cf5 socklen_t\cf0  serverAddrLen = \cf4 sizeof\cf0 (serverAddr);\
    \
    \cf4 if\cf0  ((clientSock = \cf10 socket\cf0 (\cf2 PF_INET\cf0 , \cf2 SOCK_STREAM\cf0 , \cf6 0\cf0 )) < \cf6 0\cf0 ) \{\
        \cf10 perror\cf0 (\cf3 "socket"\cf0 );\
        \cf10 exit\cf0 (-\cf6 1\cf0 );\
    \}\
    serverAddr.\cf5 sin_family\cf0  = \cf2 PF_INET\cf0 ;\
    serverAddr.\cf5 sin_addr\cf0 .\cf5 s_addr\cf0  = \cf10 inet_addr\cf0 (server_ip);\
    serverAddr.\cf5 sin_port\cf0  = \cf2 htons\cf0 (\cf2 PORT\cf0 );\
    \
    \cf4 if\cf0  (\cf10 connect\cf0 (clientSock, (\cf5 sockaddr\cf0 *)&serverAddr, serverAddrLen) < \cf6 0\cf0 ) \{\
        \cf10 perror\cf0 (\cf3 "connect failed"\cf0 );\
        \cf10 exit\cf0 (-\cf6 1\cf0 );\
    \}\
    \cf4 if\cf0  (\cf2 DEBUG\cf0 ) \{\
        \cf5 cout\cf0 <<\cf3 "TCP Connect succeeded"\cf0 <<\cf10 endl\cf0 ;\
    \}\
    \
    \cf4 return\cf0  clientSock;\
\}\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 ===============================\
}